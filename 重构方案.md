# QFlag cmd包函数式解耦重构方案

## 当前cmd包分析

### 现有文件结构
```
cmd/
├── cmd.go           # 核心命令结构体和主要API (1200+ 行)
├── internal.go      # 内部实现细节（解析逻辑、验证等）(500+ 行)
├── genhelp.go       # 帮助信息生成器 (600+ 行)
├── basic.go         # 基础标志类型方法
├── numeric.go       # 数值类型标志方法
├── collection.go    # 集合类型标志方法
├── time.go          # 时间类型标志方法
├── completion.go    # 自动补全相关
├── bash_completion.go    # Bash补全脚本生成
├── pwsh_completion.go    # PowerShell补全脚本生成
└── env.go           # 环境变量处理
```

### 当前架构问题分析

1. **单一结构体过于庞大**
   - `Cmd` 结构体有20+个字段，职责不清晰
   - 包含解析器、注册表、子命令管理、内置标志等多种职责
   - 字段访问需要大量的读写锁保护

2. **包依赖关系复杂**
   - 所有功能都耦合在cmd包中
   - 难以独立测试和维护各个功能模块
   - 修改一个功能可能影响其他功能

3. **代码组织不清晰**
   - 解析逻辑、验证逻辑、帮助生成混在一起
   - 内置标志处理硬编码在结构体方法中
   - 扩展新功能需要修改核心结构体

## 重构目标

1. **完全解耦**: 将不同功能拆分到独立的子包中
2. **函数式设计**: 改结构体方法为纯函数，通过参数传递状态
3. **降低依赖**: 各子包只依赖共享的类型定义，不相互依赖
4. **保持兼容性**: 不破坏现有的公共API
5. **便于测试**: 每个函数都可以独立测试

## 重构方案

### 1. 新的包组织结构

```
qflag/
├── cmd/
│   └── cmd.go              # 保留主要的Cmd结构体和公共API适配器
├── internal/
│   ├── types/              # 共享类型定义
│   │   ├── context.go      # 命令上下文类型
│   │   ├── config.go       # 配置类型
│   │   └── builtin.go      # 内置标志类型
│   ├── parser/             # 解析器子包（函数式）
│   │   ├── parser.go       # 核心解析函数
│   │   ├── env.go          # 环境变量处理函数
│   │   └── args.go         # 参数访问函数
│   ├── registry/           # 注册表子包（函数式）
│   │   ├── registry.go     # 标志注册函数
│   │   └── validator.go    # 验证函数
│   ├── subcmd/             # 子命令管理子包（函数式）
│   │   ├── manager.go      # 子命令管理函数
│   │   └── validator.go    # 子命令验证函数
│   ├── builtin/            # 内置标志子包（函数式）
│   │   ├── register.go     # 内置标志注册函数
│   │   └── handler.go      # 内置标志处理函数
│   ├── help/               # 帮助生成子包（函数式）
│   │   ├── generator.go    # 帮助生成函数
│   │   ├── templates.go    # 模板定义
│   │   └── writers.go      # 各部分写入函数
│   └── validator/          # 通用验证子包（函数式）
│       └── validator.go    # 通用验证函数
├── flags/                  # 标志类型包（已存在）
├── basic.go                # 基础标志方法（保持现有）
├── numeric.go              # 数值标志方法（保持现有）
├── collection.go           # 集合标志方法（保持现有）
├── time.go                 # 时间标志方法（保持现有）
├── completion.go           # 自动补全（保持现有）
├── bash_completion.go      # Bash补全（保持现有）
└── pwsh_completion.go      # PowerShell补全（保持现有）
```

### 2. 核心类型定义

#### 2.1 共享类型定义
```go
// internal/types/context.go
package types

import (
    "flag"
    "sync"
    "sync/atomic"
    "gitee.com/MM-Q/qflag/flags"
)

// CmdContext 命令上下文，包含所有必要的状态信息
// 这是所有函数操作的核心数据结构
type CmdContext struct {
    // 基本信息
    LongName  string
    ShortName string
    
    // 核心组件
    FlagSet      *flag.FlagSet
    FlagRegistry *flags.FlagRegistry
    
    // 状态管理
    Args      []string
    Parsed    atomic.Bool
    ParseOnce sync.Once
    Mutex     sync.RWMutex
    
    // 配置信息
    Config *CmdConfig
    
    // 子命令相关
    SubCmds   []*CmdContext
    SubCmdMap map[string]*CmdContext
    Parent    *CmdContext
    
    // 内置标志
    BuiltinFlags *BuiltinFlags
    
    // 钩子函数
    ParseHook func(*CmdContext) (error, bool)
}

// NewCmdContext 创建新的命令上下文
func NewCmdContext(longName, shortName string, errorHandling flag.ErrorHandling) *CmdContext {
    if longName == "" && shortName == "" {
        panic("命令长名称和短名称不能同时为空")
    }
    
    cmdName := longName
    if cmdName == "" {
        cmdName = shortName
    }
    
    return &CmdContext{
        LongName:     longName,
        ShortName:    shortName,
        FlagSet:      flag.NewFlagSet(cmdName, errorHandling),
        FlagRegistry: flags.NewFlagRegistry(),
        Args:         []string{},
        SubCmds:      []*CmdContext{},
        SubCmdMap:    make(map[string]*CmdContext),
        Config:       NewCmdConfig(),
        BuiltinFlags: NewBuiltinFlags(),
    }
}

// GetName 获取命令名称
func (ctx *CmdContext) GetName() string {
    if ctx.LongName != "" {
        return ctx.LongName
    }
    return ctx.ShortName
}
```

#### 2.2 配置类型定义
```go
// internal/types/config.go
package types

// CmdConfig 命令配置
type CmdConfig struct {
    Description      string
    Version          string
    UsageSyntax      string
    Help             string
    LogoText         string
    ModuleHelps      string
    Notes            []string
    Examples         []ExampleInfo
    UseChinese       bool
    ExitOnBuiltin    bool
    EnableCompletion bool
}

// NewCmdConfig 创建新的命令配置
func NewCmdConfig() *CmdConfig {
    return &CmdConfig{
        Notes:            []string{},
        Examples:         []ExampleInfo{},
        ExitOnBuiltin:    true,
        EnableCompletion: false,
        UseChinese:       false,
    }
}

// ExampleInfo 示例信息
type ExampleInfo struct {
    Description string // 示例描述
    Usage       string // 示例使用方式
}
```

#### 2.3 内置标志类型定义
```go
// internal/types/builtin.go
package types

import (
    "sync"
    "gitee.com/MM-Q/qflag/flags"
)

// BuiltinFlags 内置标志
type BuiltinFlags struct {
    Help       *flags.BoolFlag
    Version    *flags.BoolFlag
    Completion *flags.EnumFlag
    NameMap    sync.Map
}

// NewBuiltinFlags 创建新的内置标志
func NewBuiltinFlags() *BuiltinFlags {
    return &BuiltinFlags{
        Help:       &flags.BoolFlag{},
        Version:    &flags.BoolFlag{},
        Completion: &flags.EnumFlag{},
    }
}

// IsBuiltinFlag 检查是否为内置标志
func (bf *BuiltinFlags) IsBuiltinFlag(name string) bool {
    _, exists := bf.NameMap.Load(name)
    return exists
}

// MarkAsBuiltin 标记为内置标志
func (bf *BuiltinFlags) MarkAsBuiltin(names ...string) {
    for _, name := range names {
        bf.NameMap.Store(name, true)
    }
}
```

### 3. 函数式子包设计

#### 3.1 解析器子包（函数式设计）
```go
// internal/parser/parser.go
package parser

import (
    "fmt"
    "gitee.com/MM-Q/qflag/internal/types"
)

// ParseArgs 解析命令行参数
// 这是一个纯函数，通过参数传递状态，不依赖任何结构体方法
func ParseArgs(ctx *types.CmdContext, args []string, parseSubcmds bool) error {
    // 加载环境变量
    if err := LoadEnvVars(ctx); err != nil {
        return fmt.Errorf("环境变量加载失败: %w", err)
    }
    
    // 解析标志
    if err := ctx.FlagSet.Parse(args); err != nil {
        return fmt.Errorf("标志解析失败: %w", err)
    }
    
    // 设置非标志参数
    ctx.Mutex.Lock()
    ctx.Args = append(ctx.Args, ctx.FlagSet.Args()...)
    ctx.Mutex.Unlock()
    
    // 解析子命令
    if parseSubcmds && len(ctx.Args) > 0 {
        return ParseSubCommand(ctx)
    }
    
    return nil
}

// ParseSubCommand 解析子命令
func ParseSubCommand(ctx *types.CmdContext) error {
    ctx.Mutex.RLock()
    if len(ctx.Args) == 0 {
        ctx.Mutex.RUnlock()
        return nil
    }
    
    subCmdName := ctx.Args[0]
    subCmd, exists := ctx.SubCmdMap[subCmdName]
    ctx.Mutex.RUnlock()
    
    if exists {
        ctx.Mutex.RLock()
        remainingArgs := make([]string, len(ctx.Args)-1)
        copy(remainingArgs, ctx.Args[1:])
        ctx.Mutex.RUnlock()
        
        return ParseArgs(subCmd, remainingArgs, true)
    }
    
    return nil
}

// ParseFlagsOnly 仅解析标志，不处理子命令
func ParseFlagsOnly(ctx *types.CmdContext, args []string) error {
    return ParseArgs(ctx, args, false)
}
```

#### 3.2 环境变量处理函数
```go
// internal/parser/env.go
package parser

import (
    "fmt"
    "os"
    "gitee.com/MM-Q/qflag/flags"
    "gitee.com/MM-Q/qflag/internal/types"
)

// LoadEnvVars 从环境变量加载参数值
// 纯函数设计，不依赖结构体状态
func LoadEnvVars(ctx *types.CmdContext) error {
    processedEnvs := make(map[string]bool)
    var errors []error
    
    ctx.FlagSet.VisitAll(func(f *flag.Flag) {
        flagInstance, ok := f.Value.(flags.Flag)
        if !ok {
            return
        }
        
        envVar := flagInstance.GetEnvVar()
        if envVar == "" || processedEnvs[envVar] {
            return
        }
        
        envValue := os.Getenv(envVar)
        if envValue == "" {
            return
        }
        
        processedEnvs[envVar] = true
        
        if err := f.Value.Set(envValue); err != nil {
            errors = append(errors, fmt.Errorf("环境变量 %s 解析失败: %v", envVar, err))
        }
    })
    
    if len(errors) > 0 {
        return fmt.Errorf("环境变量加载错误: %v", errors)
    }
    
    return nil
}
```

#### 3.3 参数访问函数
```go
// internal/parser/args.go
package parser

import "gitee.com/MM-Q/qflag/internal/types"

// GetArgs 获取参数列表
func GetArgs(ctx *types.CmdContext) []string {
    ctx.Mutex.RLock()
    defer ctx.Mutex.RUnlock()
    
    result := make([]string, len(ctx.Args))
    copy(result, ctx.Args)
    return result
}

// GetArg 获取指定索引的参数
func GetArg(ctx *types.CmdContext, i int) string {
    ctx.Mutex.RLock()
    defer ctx.Mutex.RUnlock()
    
    if i >= 0 && i < len(ctx.Args) {
        return ctx.Args[i]
    }
    return ""
}

// GetArgCount 获取参数数量
func GetArgCount(ctx *types.CmdContext) int {
    ctx.Mutex.RLock()
    defer ctx.Mutex.RUnlock()
    return len(ctx.Args)
}

// SetArgs 设置参数列表（内部使用）
func SetArgs(ctx *types.CmdContext, args []string) {
    ctx.Mutex.Lock()
    defer ctx.Mutex.Unlock()
    
    ctx.Args = make([]string, len(args))
    copy(ctx.Args, args)
}
```

#### 3.4 注册表子包（函数式设计）
```go
// internal/registry/registry.go
package registry

import (
    "fmt"
    "strings"
    "gitee.com/MM-Q/qflag/flags"
    "gitee.com/MM-Q/qflag/internal/types"
)

// RegisterFlag 注册标志
// 纯函数设计，通过参数传递所有必要信息
func RegisterFlag(ctx *types.CmdContext, flag flags.Flag, longName, shortName string) error {
    // 验证标志名称
    if err := ValidateFlagNames(ctx, longName, shortName); err != nil {
        return err
    }
    
    // 注册到注册表
    return ctx.FlagRegistry.Register(flag, longName, shortName)
}

// ValidateFlagNames 验证标志名称
func ValidateFlagNames(ctx *types.CmdContext, longName, shortName string) error {
    if longName == "" && shortName == "" {
        return fmt.Errorf("标志长名称和短名称不能同时为空")
    }
    
    if longName != "" {
        if err := validateSingleFlagName(ctx, longName, "长名称"); err != nil {
            return err
        }
    }
    
    if shortName != "" {
        if err := validateSingleFlagName(ctx, shortName, "短名称"); err != nil {
            return err
        }
    }
    
    return nil
}

// validateSingleFlagName 验证单个标志名称
func validateSingleFlagName(ctx *types.CmdContext, name, nameType string) error {
    if strings.ContainsAny(name, flags.InvalidFlagChars) {
        return fmt.Errorf("标志%s '%s' 包含非法字符", nameType, name)
    }
    
    if _, exists := ctx.FlagRegistry.GetByName(name); exists {
        return fmt.Errorf("标志%s %s 已存在", nameType, name)
    }
    
    if ctx.BuiltinFlags.IsBuiltinFlag(name) {
        return fmt.Errorf("标志%s %s 是保留名称", nameType, name)
    }
    
    return nil
}

// GetFlagRegistry 获取标志注册表
func GetFlagRegistry(ctx *types.CmdContext) *flags.FlagRegistry {
    return ctx.FlagRegistry
}

// FlagExists 检查标志是否存在
func FlagExists(ctx *types.CmdContext, name string) bool {
    _, exists := ctx.FlagRegistry.GetByName(name)
    return exists
}
```

#### 3.5 子命令管理子包（函数式设计）
```go
// internal/subcmd/manager.go
package subcmd

import (
    "fmt"
    "gitee.com/MM-Q/qflag/internal/types"
)

// AddSubCommands 添加子命令
// 纯函数设计，通过参数传递父子命令上下文
func AddSubCommands(parent *types.CmdContext, children ...*types.CmdContext) error {
    if len(children) == 0 {
        return fmt.Errorf("子命令列表不能为空")
    }
    
    // 验证所有子命令
    for i, child := range children {
        if child == nil {
            return fmt.Errorf("索引 %d 的子命令不能为空", i)
        }
        
        if err := ValidateSubCommand(parent, child); err != nil {
            return fmt.Errorf("无效的子命令 %s: %w", child.GetName(), err)
        }
    }
    
    // 添加子命令
    parent.Mutex.Lock()
    defer parent.Mutex.Unlock()
    
    for _, child := range children {
        child.Parent = parent
        
        if child.LongName != "" {
            parent.SubCmdMap[child.LongName] = child
        }
        if child.ShortName != "" {
            parent.SubCmdMap[child.ShortName] = child
        }
        
        parent.SubCmds = append(parent.SubCmds, child)
    }
    
    return nil
}

// GetSubCommand 获取子命令
func GetSubCommand(ctx *types.CmdContext, name string) *types.CmdContext {
    ctx.Mutex.RLock()
    defer ctx.Mutex.RUnlock()
    return ctx.SubCmdMap[name]
}

// GetAllSubCommands 获取所有子命令
func GetAllSubCommands(ctx *types.CmdContext) []*types.CmdContext {
    ctx.Mutex.RLock()
    defer ctx.Mutex.RUnlock()
    
    result := make([]*types.CmdContext, len(ctx.SubCmds))
    copy(result, ctx.SubCmds)
    return result
}

// SubCommandExists 检查子命令是否存在
func SubCommandExists(ctx *types.CmdContext, name string) bool {
    ctx.Mutex.RLock()
    defer ctx.Mutex.RUnlock()
    _, exists := ctx.SubCmdMap[name]
    return exists
}
```

#### 3.6 子命令验证函数
```go
// internal/subcmd/validator.go
package subcmd

import (
    "fmt"
    "gitee.com/MM-Q/qflag/internal/types"
)

// ValidateSubCommand 验证子命令
func ValidateSubCommand(parent, child *types.CmdContext) error {
    if child == nil {
        return fmt.Errorf("子命令不能为空")
    }
    
    // 检测循环引用
    if HasCycle(parent, child) {
        return fmt.Errorf("检测到循环引用")
    }
    
    // 检查名称冲突
    parent.Mutex.RLock()
    defer parent.Mutex.RUnlock()
    
    if child.LongName != "" {
        if _, exists := parent.SubCmdMap[child.LongName]; exists {
            return fmt.Errorf("长名称 '%s' 已存在", child.LongName)
        }
    }
    
    if child.ShortName != "" {
        if _, exists := parent.SubCmdMap[child.ShortName]; exists {
            return fmt.Errorf("短名称 '%s' 已存在", child.ShortName)
        }
    }
    
    return nil
}

// HasCycle 检测循环引用
func HasCycle(parent, child *types.CmdContext) bool {
    if parent == nil || child == nil {
        return false
    }
    
    visited := make(map[*types.CmdContext]bool)
    return dfs(parent, child, visited, 0)
}

// dfs 深度优先搜索检测循环
func dfs(current, target *types.CmdContext, visited map[*types.CmdContext]bool, depth int) bool {
    if depth > 100 {
        return true // 防止无限递归
    }
    
    if visited[current] {
        return false
    }
    visited[current] = true
    
    if current == target {
        return true
    }
    
    // 检查子命令
    current.Mutex.RLock()
    subCmds := make([]*types.CmdContext, len(current.SubCmds))
    copy(subCmds, current.SubCmds)
    current.Mutex.RUnlock()
    
    for _, subCmd := range subCmds {
        if dfs(subCmd, target, visited, depth+1) {
            return true
        }
    }
    
    // 检查父命令
    if current.Parent != nil {
        return dfs(current.Parent, target, visited, depth+1)
    }
    
    return false
}
```

#### 3.7 内置标志管理子包（函数式设计）
```go
// internal/builtin/register.go
package builtin

import (
    "fmt"
    "gitee.com/MM-Q/qflag/flags"
    "gitee.com/MM-Q/qflag/internal/types"
)

// RegisterBuiltinFlags 注册内置标志
// 纯函数设计，通过回调函数注册标志
func RegisterBuiltinFlags(ctx *types.CmdContext, registerFunc func(*types.CmdContext, flags.Flag, string, string, interface{}, string)) {
    // 注册帮助标志
    registerHelpFlag(ctx, registerFunc)
    
    // 仅在根命令注册版本和补全标志
    if ctx.Parent == nil {
        registerVersionFlag(ctx, registerFunc)
        registerCompletionFlag(ctx, registerFunc)
    }
}

// registerHelpFlag 注册帮助标志
func registerHelpFlag(ctx *types.CmdContext, registerFunc func(*types.CmdContext, flags.Flag, string, string, interface{}, string)) {
    registerFunc(ctx, ctx.BuiltinFlags.Help, flags.HelpFlagName, flags.HelpFlagShortName, false, flags.HelpFlagUsageEn)
    ctx.BuiltinFlags.MarkAsBuiltin(flags.HelpFlagName, flags.HelpFlagShortName)
}

// registerVersionFlag 注册版本标志
func registerVersionFlag(ctx *types.CmdContext, registerFunc func(*types.CmdContext, flags.Flag, string, string, interface{}, string)) {
    if ctx.Config.Version == "" {
        return
    }
    
    versionUsage := flags.VersionFlagUsageEn
    if ctx.Config.UseChinese {
        versionUsage = flags.VersionFlagUsageZh
    }
    
    registerFunc(ctx, ctx.BuiltinFlags.Version, flags.VersionFlagLongName, flags.VersionFlagShortName, false, versionUsage)
    ctx.BuiltinFlags.MarkAsBuiltin(flags.VersionFlagLongName, flags.VersionFlagShortName)
}

// registerCompletionFlag 注册补全标志
func registerCompletionFlag(ctx *types.CmdContext, registerFunc func(*types.CmdContext, flags.Flag, string, string, interface{}, string)) {
    if !ctx.Config.EnableCompletion {
        return
    }
    
    shellDesc := flags.CompletionShellDescEN
    if ctx.Config.UseChinese {
        shellDesc = flags.CompletionShellDescCN
    }
    
    // 这里需要特殊处理枚举标志
    enumFlag := ctx.BuiltinFlags.Completion
    // 设置枚举选项等...
    
    registerFunc(ctx, enumFlag, flags.CompletionShellFlagLongName, flags.CompletionShellFlagShortName, flags.ShellNone, fmt.Sprintf(shellDesc, flags.ShellSlice))
    ctx.BuiltinFlags.MarkAsBuiltin(flags.CompletionShellFlagLongName, flags.CompletionShellFlagShortName)
}
```

#### 3.8 内置标志处理函数
```go
// internal/builtin/handler.go
package builtin

import (
    "fmt"
    "gitee.com/MM-Q/qflag/flags"
    "gitee.com/MM-Q/qflag/internal/types"
)

// HandleBuiltinFlags 处理内置标志
// 纯函数设计，返回是否需要退出和错误信息
func HandleBuiltinFlags(ctx *types.CmdContext, printHelpFunc func(*types.CmdContext), generateCompletionFunc func(*types.CmdContext, string) (string, error)) (bool, error) {
    // 处理帮助标志
    if ctx.BuiltinFlags.Help.Get() {
        printHelpFunc(ctx)
        return ctx.Config.ExitOnBuiltin, nil
    }
    
    // 仅在根命令处理版本和补全标志
    if ctx.Parent == nil {
        // 处理版本标志
        if ctx.BuiltinFlags.Version.Get() && ctx.Config.Version != "" {
            fmt.Println(ctx.Config.Version)
            return ctx.Config.ExitOnBuiltin, nil
        }
        
        // 处理自动补全标志
        if ctx.Config.EnableCompletion {
            shell := ctx.BuiltinFlags.Completion.Get()
            if shell != flags.ShellNone {
                completion, err := generateCompletionFunc(ctx, shell)
                if err != nil {
                    return false, err
                }
                fmt.Println(completion)
                return ctx.Config.ExitOnBuiltin, nil
            }
        }
    }
    
    // 验证枚举标志
    return false, ValidateEnumFlags(ctx)
}

// ValidateEnumFlags 验证枚举类型标志
func ValidateEnumFlags(ctx *types.CmdContext) error {
    for _, meta := range ctx.FlagRegistry.GetAllFlagMetas() {
        if meta.GetFlagType() != flags.FlagTypeEnum {
            continue
        }
        
        enumFlag, ok := meta.GetFlag().(*flags.EnumFlag)
        if !ok {
            continue
        }
        
        if err := enumFlag.IsCheck(enumFlag.Get()); err != nil {
            return fmt.Errorf("标志 %s: %w", meta.GetName(), err)
        }
    }
    
    return nil
}
```

#### 3.9 帮助生成子包（函数式设计）
```go
// internal/help/generator.go
package help

import (
    "bytes"
    "gitee.com/MM-Q/qflag/internal/types"
)

// GenerateHelp 生成帮助信息
// 纯函数设计，不依赖任何结构体状态
func GenerateHelp(ctx *types.CmdContext) string {
    if ctx.Config.Help != "" {
        return ctx.Config.Help
    }
    
    var buf bytes.Buffer
    
    // 选择模板
    template := &EnglishTemplate
    if ctx.Config.UseChinese {
        template = &ChineseTemplate
    }
    
    // 写入各个部分
    WriteCommandHeader(ctx, template, &buf)
    WriteLogoText(ctx, &buf)
    WriteUsageLine(ctx, template, &buf)
    WriteOptions(ctx, template, &buf)
    WriteSubCommands(ctx, template, &buf)
    WriteModuleHelps(ctx, &buf)
    WriteExamples(ctx, template, &buf)
    WriteNotes(ctx, template, &buf)
    
    return buf.String()
}

// PrintHelp 打印帮助信息
func PrintHelp(ctx *types.CmdContext) {
    fmt.Println(GenerateHelp(ctx))
}
```

#### 3.10 帮助信息写入函数
```go
// internal/help/writers.go
package help

import (
    "bytes"
    "fmt"
    "gitee.com/MM-Q/qflag/internal/types"
)

// WriteCommandHeader 写入命令头部
func WriteCommandHeader(ctx *types.CmdContext, template *HelpTemplate, buf *bytes.Buffer) {
    if ctx.LongName != "" && ctx.ShortName != "" {
        fmt.Fprintf(buf, template.CmdNameWithShort, ctx.LongName, ctx.ShortName)
    } else if ctx.LongName != "" {
        fmt.Fprintf(buf, template.CmdName, ctx.LongName)
    } else {
        fmt.Fprintf(buf, template.CmdName, ctx.ShortName)
    }
    
    if ctx.Config.Description != "" {
        fmt.Fprintf(buf, template.CmdDescription, ctx.Config.Description)
    }
}

// WriteLogoText 写入Logo文本
func WriteLogoText(ctx *types.CmdContext, buf *bytes.Buffer) {
    if ctx.Config.LogoText != "" {
        buf.WriteString(ctx.Config.LogoText + "\n")
    }
}

// 其他写入函数类似...
```

### 4. 主cmd包适配层

#### 4.1 简化的Cmd结构体（适配器模式）
```go
// cmd/cmd.go
package cmd

import (
    "flag"
    "fmt"
    "os"
    "sync"
    
    "gitee.com/MM-Q/qflag/flags"
    "gitee.com/MM-Q/qflag/internal/types"
    "gitee.com/MM-Q/qflag/internal/parser"
    "gitee.com/MM-Q/qflag/internal/registry"
    "gitee.com/MM-Q/qflag/internal/subcmd"
    "gitee.com/MM-Q/qflag/internal/builtin"
    "gitee.com/MM-Q/qflag/internal/help"
)

// Cmd 简化的命令结构体，作为适配器连接内部函数式API和外部面向对象API
type Cmd struct {
    ctx *types.CmdContext // 内部上下文，包含所有状态
}

// NewCmd 创建新命令
func NewCmd(longName, shortName string, errorHandling flag.ErrorHandling) *Cmd {
    // 创建内部上下文
    ctx := types.NewCmdContext(longName, shortName, errorHandling)
    
    // 创建命令实例
    cmd := &Cmd{ctx: ctx}
    
    // 注册内置标志
    builtin.RegisterBuiltinFlags(ctx, cmd.registerFlag)
    
    return cmd
}

// Parse 解析命令行参数
func (c *Cmd) Parse(args []string) error {
    var err error
    c.ctx.ParseOnce.Do(func() {
        defer c.ctx.Parsed.Store(true)
        
        // 添加默认注意事项
        if c.ctx.Config.UseChinese {
            c.ctx.Config.Notes = append(c.ctx.Config.Notes, ChineseTemplate.DefaultNote)
        } else {
            c.ctx.Config.Notes = append(c.ctx.Config.Notes, EnglishTemplate.DefaultNote)
        }
        
        // 解析参数
        if err = parser.ParseArgs(c.ctx, args, true); err != nil {
            return
        }
        
        // 处理内置标志
        shouldExit, handleErr := builtin.HandleBuiltinFlags(c.ctx, help.PrintHelp, c.generateShellCompletion)
        if handleErr != nil {
            err = handleErr
            return
        }
        
        if shouldExit {
            if c.ctx.Config.ExitOnBuiltin {
                os.Exit(0)
            }
            return
        }
        
        // 执行解析钩子
        if c.ctx.ParseHook != nil {
            hookErr, hookExit := c.ctx.ParseHook(c.ctx)
            if hookErr != nil {
                err = hookErr
                return
            }
            if hookExit {
                if c.ctx.Config.ExitOnBuiltin {
                    os.Exit(0)
                }
                return
            }
        }
    })
    
    return err
}

// AddSubCmd 添加子命令
func (c *Cmd) AddSubCmd(subCmds ...*Cmd) error {
    contexts := make([]*types.CmdContext, len(subCmds))
    for i, cmd := range subCmds {
        contexts[i] = cmd.ctx
    }
    return subcmd.AddSubCommands(c.ctx, contexts...)
}

// Args 获取参数
func (c *Cmd) Args() []string {
    return parser.GetArgs(c.ctx)
}

// Arg 获取指定参数
func (c *Cmd) Arg(i int) string {
    return parser.GetArg(c.ctx, i)
}

// NArg 获取参数数量
func (c *Cmd) NArg() int {
    return parser.GetArgCount(c.ctx)
}

// GetHelp 获取帮助信息
func (c *Cmd) GetHelp() string {
    return help.GenerateHelp(c.ctx)
}

// PrintHelp 打印帮助信息
func (c *Cmd) PrintHelp() {
    help.PrintHelp(c.ctx)
}

// SetVersion 设置版本信息
func (c *Cmd) SetVersion(version string) {
    c.ctx.Mutex.Lock()
    defer c.ctx.Mutex.Unlock()
    c.ctx.Config.Version = version
}

// GetVersion 获取版本信息
func (c *Cmd) GetVersion() string {
    c.ctx.Mutex.RLock()
    defer c.ctx.Mutex.RUnlock()
    return c.ctx.Config.Version
}

// 其他方法类似地通过函数调用实现...

// 内部辅助方法
func (c *Cmd) registerFlag(ctx *types.CmdContext, flag flags.Flag, longName, shortName string, value interface{}, usage string) {
    // 设置默认值
    flag.Set(fmt.Sprintf("%v", value))
    
    // 注册到注册表
    if err := registry.RegisterFlag(ctx, flag, longName, shortName); err != nil {
        panic(err)
    }
    
    // 注册到FlagSet
    ctx.FlagSet.Var(flag, longName, usage)
    if shortName != "" {
        ctx.FlagSet.Var(flag, shortName, usage)
    }
}

func (c *Cmd) generateShellCompletion(ctx *types.CmdContext, shell string) (string, error) {
    // 实现生成补全脚本的逻辑
    return "", nil // 简化示例
}
```

### 5. 重构实施步骤

#### 第一阶段：创建基础结构（第1-2周）

**第1步：创建共享类型定义**
```bash
# 创建目录结构
mkdir -p internal/types
mkdir -p internal/parser
mkdir -p internal/registry
mkdir -p internal/subcmd
mkdir -p internal/builtin
mkdir -p internal/help
mkdir -p internal/validator

# 创建类型定义文件
touch internal/types/context.go
touch internal/types/config.go
touch internal/types/builtin.go
```

**重构动作示例：**
```go
// 从 cmd.go 提取核心类型定义
// 原代码：cmd.go 中的 Cmd 结构体和 userInfo 结构体

// 重构后：internal/types/context.go
package types

import (
    "flag"
    "sync"
    "sync/atomic"
    "gitee.com/MM-Q/qflag/flags"
)

// CmdContext 命令上下文，包含所有必要的状态信息
type CmdContext struct {
    // 基本信息
    LongName  string
    ShortName string
    
    // 核心组件
    FlagSet      *flag.FlagSet
    FlagRegistry *flags.FlagRegistry
    
    // 状态管理
    Args      []string
    Parsed    atomic.Bool
    ParseOnce sync.Once
    Mutex     sync.RWMutex
    
    // 配置信息
    Config *CmdConfig
    
    // 子命令相关
    SubCmds   []*CmdContext
    SubCmdMap map[string]*CmdContext
    Parent    *CmdContext
    
    // 内置标志
    BuiltinFlags *BuiltinFlags
    
    // 钩子函数
    ParseHook func(*CmdContext) (error, bool)
}
```

**第2步：创建解析器函数**
```bash
# 创建解析器文件
touch internal/parser/parser.go
touch internal/parser/env.go
touch internal/parser/args.go
```

**重构动作示例：**
```go
// 从 internal.go 提取解析逻辑
// 原代码：internal.go 中的 parseCommon 方法

// 重构后：internal/parser/parser.go
package parser

import (
    "fmt"
    "gitee.com/MM-Q/qflag/internal/types"
)

// ParseArgs 解析命令行参数
func ParseArgs(ctx *types.CmdContext, args []string, parseSubcmds bool) error {
    // 将原 parseCommon 逻辑转换为纯函数
}
```

#### 第二阶段：实现核心功能（第3-4周）

**第3步：实现注册表函数**
```bash
# 创建注册表文件
touch internal/registry/registry.go
touch internal/registry/validator.go
```

**重构动作示例：**
```go
// 从 cmd.go 和 internal.go 提取标志注册和验证逻辑
// 原代码：cmd.go 中的标志注册方法和 internal.go 中的 validateFlag 方法

// 重构后：internal/registry/registry.go
package registry

import (
    "fmt"
    "strings"
    "gitee.com/MM-Q/qflag/flags"
    "gitee.com/MM-Q/qflag/internal/types"
)

// RegisterFlag 注册标志
func RegisterFlag(ctx *types.CmdContext, flag flags.Flag, longName, shortName string) error {
    // 实现标志注册逻辑
}
```

**第4步：实现子命令管理函数**
```bash
# 创建子命令管理文件
touch internal/subcmd/manager.go
touch internal/subcmd/validator.go
```

**重构动作示例：**
```go
// 从 cmd.go 和 internal.go 提取子命令管理和验证逻辑
// 原代码：cmd.go 中的 AddSubCmd 方法和 internal.go 中的 validateSubCmd 方法

// 重构后：internal/subcmd/manager.go
package subcmd

import (
    "fmt"
    "gitee.com/MM-Q/qflag/internal/types"
)

// AddSubCommands 添加子命令
func AddSubCommands(parent *types.CmdContext, children ...*types.CmdContext) error {
    // 实现子命令添加逻辑
}
```

#### 第三阶段：实现辅助功能（第5-6周）

**第5步：实现内置标志管理函数**
```bash
# 创建内置标志管理文件
touch internal/builtin/register.go
touch internal/builtin/handler.go
```

**重构动作示例：**
```go
// 从 internal.go 提取内置标志处理逻辑
// 原代码：internal.go 中的 registerBuiltinFlags 和 handleBuiltinFlags 方法

// 重构后：internal/builtin/register.go
package builtin

import (
    "fmt"
    "gitee.com/MM-Q/qflag/flags"
    "gitee.com/MM-Q/qflag/internal/types"
)

// RegisterBuiltinFlags 注册内置标志
func RegisterBuiltinFlags(ctx *types.CmdContext, registerFunc func(*types.CmdContext, flags.Flag, string, string, interface{}, string)) {
    // 实现内置标志注册逻辑
}
```

**第6步：实现帮助生成函数**
```bash
# 创建帮助生成文件
touch internal/help/generator.go
touch internal/help/templates.go
touch internal/help/writers.go
```

**重构动作示例：**
```go
// 从 genhelp.go 提取帮助生成逻辑
// 原代码：genhelp.go 中的 generateHelpInfo 方法

// 重构后：internal/help/generator.go
package help

import (
    "bytes"
    "gitee.com/MM-Q/qflag/internal/types"
)

// GenerateHelp 生成帮助信息
func GenerateHelp(ctx *types.CmdContext) string {
    // 实现帮助生成逻辑
}
```

#### 第四阶段：适配层和测试（第7-8周）

**第7步：实现适配层**
```bash
# 修改 cmd.go
```

**重构动作示例：**
```go
// 重构 cmd.go 为适配器
// 原代码：cmd.go 中的 Cmd 结构体和方法

// 重构后：cmd/cmd.go
package cmd

import (
    "flag"
    "fmt"
    "os"
    
    "gitee.com/MM-Q/qflag/flags"
    "gitee.com/MM-Q/qflag/internal/types"
    "gitee.com/MM-Q/qflag/internal/parser"
    // 其他导入...
)

// Cmd 简化的命令结构体，作为适配器
type Cmd struct {
    ctx *types.CmdContext
}

// NewCmd 创建新命令
func NewCmd(longName, shortName string, errorHandling flag.ErrorHandling) *Cmd {
    // 实现适配逻辑
}

// 其他适配方法...
```

**第8步：编写测试**
```bash
# 创建测试文件
touch internal/parser/parser_test.go
touch internal/registry/registry_test.go
touch internal/subcmd/manager_test.go
touch internal/builtin/handler_test.go
touch internal/help/generator_test.go
```

**测试示例：**
```go
// internal/parser/parser_test.go
package parser

import (
    "testing"
    "flag"
    "gitee.com/MM-Q/qflag/internal/types"
)

func TestParseArgs(t *testing.T) {
    // 创建测试上下文
    ctx := types.NewCmdContext("test", "t", flag.ContinueOnError)
    
    // 测试基本解析
    err := ParseArgs(ctx, []string{"--help"}, true)
    if err != nil {
        t.Errorf("解析失败: %v", err)
    }
    
    // 其他测试用例...
}
```

### 6. 函数式设计的优势

#### 6.1 完全解耦
- 每个子包只依赖共享的types包，不相互依赖
- 所有功能都通过纯函数实现，没有隐藏的状态
- 可以独立开发和测试每个功能模块

#### 6.2 状态集中管理
- 所有状态都在CmdContext中，避免状态分散
- 通过参数传递状态，使函数行为更可预测
- 减少了锁的使用范围，提高并发性能

#### 6.3 测试友好
- 每个函数都可以独立测试，不需要复杂的模拟
- 可以轻松构造测试上下文，验证特定场景
- 边界情况更容易测试

#### 6.4 扩展性强
- 新增功能只需添加新的函数，不需要修改现有结构
- 可以轻松替换任何功能模块，不影响其他部分
- 支持更灵活的组合方式

### 7. 使用示例对比

#### 7.1 保持现有API
```go
// 现有代码完全不需要修改
cmd := qflag.NewCmd("myapp", "", flag.ExitOnError)
nameFlag := cmd.String("name", "n", "", "应用名称")
cmd.Parse(os.Args[1:])
fmt.Println("名称:", nameFlag.Get())
```

#### 7.2 新的函数式API（内部使用）
```go
// 创建上下文
ctx := types.NewCmdContext("myapp", "", flag.ExitOnError)

// 注册标志
nameFlag := &flags.StringFlag{}
registry.RegisterFlag(ctx, nameFlag, "name", "n", "", "应用名称")

// 解析参数
parser.ParseArgs(ctx, os.Args[1:], true)

// 处理内置标志
builtin.HandleBuiltinFlags(ctx, help.PrintHelp, generateCompletion)

// 获取参数
args := parser.GetArgs(ctx)
fmt.Println("名称:", nameFlag.Get())
```

### 8. 实施时间表

| 阶段 | 周次 | 主要任务 | 交付物 | 验收标准 |
|------|------|----------|--------|----------|
| 第一阶段 | 第1-2周 | 创建基础结构 | types包、parser包基础实现 | 类型定义完成，基本解析功能可用 |
| 第二阶段 | 第3-4周 | 实现核心功能 | registry包、subcmd包实现 | 标志注册和子命令管理功能完整 |
| 第三阶段 | 第5-6周 | 实现辅助功能 | builtin包、help包实现 | 内置标志处理和帮助生成功能完整 |
| 第四阶段 | 第7-8周 | 适配层和测试 | 完整的重构版本和测试 | 所有功能正常工作，API兼容性保持 |

### 9. 风险控制

#### 9.1 向后兼容性保证
- 通过适配层保持公共API不变
- 内部重构不影响外部使用
- 保持现有的错误处理方式

#### 9.2 渐进式重构
- 每个子包可以独立开发和测试
- 可以逐步替换现有功能
- 随时可以回滚到上一个稳定版本

#### 9.3 充分测试
- 为每个函数编写单元测试
- 测试各种边界情况和错误处理
- 确保所有现有功能正常工作

### 10. 总结

这个函数式解耦重构方案通过将结构体方法转换为纯函数，并将不同功能拆分到独立子包中，显著降低了包之间的依赖关系。通过集中状态管理和函数式设计，提高了代码的可测试性、可维护性和扩展性。

**主要收益：**
1. **完全解耦**：各功能模块独立，不相互依赖
2. **函数式设计**：通过参数传递状态，行为更可预测
3. **测试友好**：每个函数都可以独立测试
4. **扩展性强**：新增功能只需添加新函数
5. **性能优化**：减少锁竞争，提高并发性能

整个重构可以在8周内完成，风险可控，收益明显，同时保持了对现有用户代码的兼容性。
