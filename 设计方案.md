# SizeFlag 大小标志设计方案

## 概述

SizeFlag 是一个专门用于处理大小单位的标志类型，支持用户以直观的方式输入各种大小值，如文件大小、内存大小、磁盘空间等。该标志能够自动解析带单位的字符串（如 "10KB", "5MB", "2GB"）并转换为字节数。

## 设计目标

1. **用户友好**：支持常见的大小单位表示法
2. **灵活性**：支持多种单位格式和大小写
3. **精确性**：使用 int64 存储字节数，支持大文件
4. **兼容性**：与现有标志系统无缝集成
5. **验证性**：提供合理的范围验证

## 核心特性

### 1. 支持的单位

#### 二进制单位（1024进制）
- **B/Byte/Bytes**: 字节
- **K/KB/KiB**: 千字节 (1024 bytes)
- **M/MB/MiB**: 兆字节 (1024² bytes)
- **G/GB/GiB**: 吉字节 (1024³ bytes)
- **T/TB/TiB**: 太字节 (1024⁴ bytes)
- **P/PB/PiB**: 拍字节 (1024⁵ bytes)

#### 十进制单位（1000进制）
- **kB**: 千字节 (1000 bytes)
- **MB**: 兆字节 (1000² bytes)
- **GB**: 吉字节 (1000³ bytes)
- **TB**: 太字节 (1000⁴ bytes)
- **PB**: 拍字节 (1000⁵ bytes)

### 2. 输入格式支持

```
有效输入示例：
- "1024"          -> 1024 bytes (纯数字，按字节解析)
- "10K"           -> 10240 bytes
- "5MB"           -> 5242880 bytes
- "2.5GB"         -> 2684354560 bytes
- "1.5 TiB"       -> 1649267441664 bytes
- "100 kb"        -> 102400 bytes
- "0.5m"          -> 524288 bytes
- "0"             -> 0 bytes
```

## 技术实现

### 1. 数据结构

```go
// SizeFlag 大小标志结构体
type SizeFlag struct {
    BaseFlag[int64]           // 继承基础标志，存储字节数
    allowDecimal    bool      // 是否允许小数
    allowNegative   bool      // 是否允许负数
    mu              sync.RWMutex
}

// SizeUnit 大小单位定义
type SizeUnit struct {
    Name       string  // 单位名称
    Multiplier int64   // 乘数
    IsBinary   bool    // 是否为二进制单位
}
```

### 2. 单位映射表

```go
var sizeUnits = map[string]SizeUnit{
    // 字节
    "b":     {Name: "Byte", Multiplier: 1, IsBinary: true},
    "byte":  {Name: "Byte", Multiplier: 1, IsBinary: true},
    "bytes": {Name: "Byte", Multiplier: 1, IsBinary: true},
    
    // 二进制单位 (1024)
    "k":     {Name: "KiB", Multiplier: 1024, IsBinary: true},
    "kb":    {Name: "KiB", Multiplier: 1024, IsBinary: true},
    "kib":   {Name: "KiB", Multiplier: 1024, IsBinary: true},
    "m":     {Name: "MiB", Multiplier: 1024 * 1024, IsBinary: true},
    "mb":    {Name: "MiB", Multiplier: 1024 * 1024, IsBinary: true},
    "mib":   {Name: "MiB", Multiplier: 1024 * 1024, IsBinary: true},
    "g":     {Name: "GiB", Multiplier: 1024 * 1024 * 1024, IsBinary: true},
    "gb":    {Name: "GiB", Multiplier: 1024 * 1024 * 1024, IsBinary: true},
    "gib":   {Name: "GiB", Multiplier: 1024 * 1024 * 1024, IsBinary: true},
    
    // 十进制单位 (1000)
    "kb_decimal": {Name: "kB", Multiplier: 1000, IsBinary: false},
    "mb_decimal": {Name: "MB", Multiplier: 1000 * 1000, IsBinary: false},
    "gb_decimal": {Name: "GB", Multiplier: 1000 * 1000 * 1000, IsBinary: false},
}
```

### 3. 核心方法

#### 解析方法
```go
func (f *SizeFlag) Set(value string) error {
    f.mu.Lock()
    defer f.mu.Unlock()
    
    // 处理空值
    if strings.TrimSpace(value) == "" {
        return nil
    }
    
    // 解析大小值
    size, err := f.parseSize(value)
    if err != nil {
        return fmt.Errorf("invalid size format: %v", err)
    }
    
    // 验证int64范围
    if size > math.MaxInt64 || size < math.MinInt64 {
        return fmt.Errorf("size out of int64 range")
    }
    
    f.value = size
    f.isSet = true
    return nil
}
=======

func (f *SizeFlag) parseSize(input string) (int64, error) {
    // 清理输入
    input = strings.TrimSpace(input)
    
    // 正则表达式匹配数字和单位
    re := regexp.MustCompile(`^([0-9]*\.?[0-9]+)\s*([a-zA-Z]*)$`)
    matches := re.FindStringSubmatch(input)
    
    if len(matches) != 3 {
        return 0, fmt.Errorf("invalid format")
    }
    
    // 解析数值部分
    numStr := matches[1]
    unitStr := strings.ToLower(matches[2])
    
    var num float64
    var err error
    
    if strings.Contains(numStr, ".") {
        if !f.allowDecimal {
            return 0, fmt.Errorf("decimal values not allowed")
        }
        num, err = strconv.ParseFloat(numStr, 64)
    } else {
        intVal, parseErr := strconv.ParseInt(numStr, 10, 64)
        if parseErr != nil {
            return 0, parseErr
        }
        num = float64(intVal)
    }
    
    if err != nil {
        return 0, fmt.Errorf("invalid number: %v", err)
    }
    
    // 处理负数
    if num < 0 && !f.allowNegative {
        return 0, fmt.Errorf("negative values not allowed")
    }
    
    // 处理单位
    var multiplier int64 = 1 // 默认为字节
    
    if unitStr != "" {
        // 查找单位
        unit, exists := sizeUnits[unitStr]
        if !exists {
            return 0, fmt.Errorf("unknown unit: %s", unitStr)
        }
        multiplier = unit.Multiplier
    }
    
    // 计算最终大小
    result := int64(num * float64(multiplier))
    
    return result, nil
}
```

#### 格式化方法
```go
func (f *SizeFlag) String() string {
    f.mu.RLock()
    defer f.mu.RUnlock()
    
    size := f.Get()
    
    // 处理零值
    if size == 0 {
        return "0B"
    }
    
    return f.formatSize(size)
}

func (f *SizeFlag) formatSize(bytes int64) string {
    if bytes < 0 {
        return fmt.Sprintf("-%s", f.formatSize(-bytes))
    }
    
    units := []struct {
        name string
        size int64
    }{
        {"PiB", 1024 * 1024 * 1024 * 1024 * 1024},
        {"TiB", 1024 * 1024 * 1024 * 1024},
        {"GiB", 1024 * 1024 * 1024},
        {"MiB", 1024 * 1024},
        {"KiB", 1024},
        {"B", 1},
    }
    
    for _, unit := range units {
        if bytes >= unit.size {
            value := float64(bytes) / float64(unit.size)
            if value == float64(int64(value)) {
                return fmt.Sprintf("%.0f%s", value, unit.name)
            }
            return fmt.Sprintf("%.1f%s", value, unit.name)
        }
    }
    
    return fmt.Sprintf("%dB", bytes)
}
```

#### 配置方法
```go
// SetAllowDecimal 设置是否允许小数
func (f *SizeFlag) SetAllowDecimal(allow bool) *SizeFlag {
    f.mu.Lock()
    defer f.mu.Unlock()
    f.allowDecimal = allow
    return f
}

// SetAllowNegative 设置是否允许负数
func (f *SizeFlag) SetAllowNegative(allow bool) *SizeFlag {
    f.mu.Lock()
    defer f.mu.Unlock()
    f.allowNegative = allow
    return f
}


```

#### 辅助方法
```go
// GetBytes 获取字节数
func (f *SizeFlag) GetBytes() int64 {
    return f.Get()
}

// GetKiB 获取KiB数
func (f *SizeFlag) GetKiB() float64 {
    return float64(f.Get()) / 1024
}

// GetMiB 获取MiB数
func (f *SizeFlag) GetMiB() float64 {
    return float64(f.Get()) / (1024 * 1024)
}

// GetGiB 获取GiB数
func (f *SizeFlag) GetGiB() float64 {
    return float64(f.Get()) / (1024 * 1024 * 1024)
}

// IsZero 检查是否为零
func (f *SizeFlag) IsZero() bool {
    return f.Get() == 0
}
```

## 使用示例

### 1. 基本使用

```go
package main

import (
    "fmt"
    "gitee.com/MM-Q/qflag"
)

func main() {
    // 创建大小标志
    maxSize := qflag.Size("max-size", "s", 1024*1024*1024, "最大文件大小")
    
    // 配置选项
    maxSize.SetAllowDecimal(true)
    
    qflag.Parse()
    
    fmt.Printf("最大文件大小: %s (%d bytes)\n", maxSize.String(), maxSize.GetBytes())
    fmt.Printf("最大文件大小: %.2f GB\n", maxSize.GetGiB())
}
```

### 2. 高级配置

```go
// 内存限制标志
memLimit := qflag.Size("memory", "m", 512*1024*1024, "内存限制")
memLimit.SetAllowDecimal(true)

// 磁盘配额标志
diskQuota := qflag.Size("quota", "q", 1024*1024*1024, "磁盘配额")
diskQuota.SetAllowNegative(false)

// 缓存大小标志
cacheSize := qflag.Size("cache", "c", 100*1024*1024, "缓存大小")
cacheSize.SetAllowDecimal(false)
```

### 3. 命令行使用示例

```bash
# 基本使用
./app --max-size 500MB
./app --max-size 2.5GB
./app --max-size 1024        # 纯数字，按字节解析 (1024 bytes)

# 不同单位
./app --memory 512MiB
./app --memory 0.5GB
./app --memory 536870912     # 纯数字，按字节解析 (536870912 bytes)

# 零值
./app --quota 0
```

## 验证器集成

### 1. 内置验证器

```go
// SizeRangeValidator 大小范围验证器
type SizeRangeValidator struct {
    Min int64
    Max int64
}

func (v *SizeRangeValidator) Validate(value any) error {
    size, ok := value.(int64)
    if !ok {
        return errors.New("value is not int64")
    }
    
    if size < v.Min {
        return fmt.Errorf("size %d is less than minimum %d", size, v.Min)
    }
    
    if size > v.Max {
        return fmt.Errorf("size %d is greater than maximum %d", size, v.Max)
    }
    
    return nil
}

// PowerOfTwoValidator 2的幂验证器
type PowerOfTwoValidator struct{}

func (v *PowerOfTwoValidator) Validate(value any) error {
    size, ok := value.(int64)
    if !ok {
        return errors.New("value is not int64")
    }
    
    if size <= 0 || (size&(size-1)) != 0 {
        return fmt.Errorf("size %d is not a power of 2", size)
    }
    
    return nil
}
```

### 2. 使用验证器

```go
// 如果需要自定义范围验证，可以使用验证器
sizeFlag.SetValidator(&SizeRangeValidator{
    Min: 1024,           // 1KB
    Max: 10*1024*1024*1024, // 10GB
})

// 设置2的幂验证
bufferSize.SetValidator(&PowerOfTwoValidator{})
```

## 错误处理

### 1. 错误类型

```go
var (
    ErrInvalidSizeFormat   = errors.New("invalid size format")
    ErrUnknownUnit        = errors.New("unknown unit")
    ErrNegativeNotAllowed = errors.New("negative values not allowed")
    ErrDecimalNotAllowed  = errors.New("decimal values not allowed")
    ErrSizeOutOfRange     = errors.New("size out of range")
)
```

### 2. 错误示例

```
输入: "abc"
错误: invalid size format

输入: "10XB"
错误: unknown unit: XB

输入: "-5MB" (当不允许负数时)
错误: negative values not allowed

输入: "1.5GB" (当不允许小数时)
错误: decimal values not allowed

输入: "999999999999999999999PB" (超出int64范围时)
错误: size out of int64 range
```

## 测试用例

### 1. 基本解析测试

```go
func TestSizeFlag_BasicParsing(t *testing.T) {
    tests := []struct {
        input    string
        expected int64
    }{
        {"1024", 1024},                              // 纯数字，按字节解析
        {"1K", 1024},
        {"1KB", 1024},
        {"1KiB", 1024},
        {"1M", 1024 * 1024},
        {"1MB", 1024 * 1024},
        {"1G", 1024 * 1024 * 1024},
        {"2.5MB", int64(2.5 * 1024 * 1024)},
        {"0", 0},
        {"536870912", 536870912},                    // 纯数字大值，按字节解析
    }
    
    for _, test := range tests {
        flag := &SizeFlag{}
        flag.Init("test", "", 0, "test")
        flag.SetAllowDecimal(true)
        
        err := flag.Set(test.input)
        assert.NoError(t, err)
        assert.Equal(t, test.expected, flag.Get())
    }
}
```

### 2. 错误处理测试

```go
func TestSizeFlag_ErrorHandling(t *testing.T) {
    tests := []struct {
        input       string
        allowDecimal bool
        shouldError bool
    }{
        {"abc", false, true},
        {"10XB", false, true},
        {"1.5MB", false, true},
        {"1.5MB", true, false},
        {"-5MB", false, true},
    }
    
    for _, test := range tests {
        flag := &SizeFlag{}
        flag.Init("test", "", 0, "test")
        flag.SetAllowDecimal(test.allowDecimal)
        
        err := flag.Set(test.input)
        if test.shouldError {
            assert.Error(t, err)
        } else {
            assert.NoError(t, err)
        }
    }
}
```

## 性能考虑

1. **正则表达式缓存**：预编译正则表达式避免重复编译
2. **单位映射表**：使用map快速查找单位
3. **读写锁**：使用RWMutex提高并发读取性能
4. **内存分配**：避免不必要的字符串分配

## 扩展性

1. **自定义单位**：支持用户定义新的单位
2. **本地化**：支持不同语言的单位名称
3. **精度控制**：支持不同的精度要求
4. **格式化选项**：支持不同的输出格式

## 总结

SizeFlag 提供了一个完整的大小单位处理解决方案，具有以下优势：

1. **用户友好**：支持直观的大小单位输入
2. **功能完整**：支持多种单位、特殊值、验证等
3. **性能优良**：高效的解析和格式化算法
4. **扩展性强**：易于添加新功能和自定义选项
5. **类型安全**：基于泛型的类型安全设计

该设计方案为qflag库增加了强大的大小单位处理能力，特别适用于文件操作、内存管理、网络配置等场景。